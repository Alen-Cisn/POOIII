@using Txt.Shared.Dtos
@using Txt.Ui.Services.Interfaces
@inject INotesService NotesService
@inject ISnackbar Snackbar
@inject ILogger<NoteLines> Logger

<MudCard>
    <MudCardContent>
        @foreach (var noteLine in Lines)
        {
            <NoteLine InitialContent="@noteLine.Content" Id="@noteLine.Id" OnLineUpdated="HandleLineUpdated"
                OnRequestFocus="HandleRequestFocus" />
        }
    </MudCardContent>
</MudCard>

@code {
    [Parameter]
    public IEnumerable<NoteLineDto> Lines { get; set; }

    [Parameter]
    public int NoteId { get; set; }

    private int? currentFocusedId;

    private async Task HandleRequestFocus(int id)
    {
        if (currentFocusedId != id)
        {
            currentFocusedId = id;
            StateHasChanged(); // Re-render to update focus
        }

        // Optionally, you can set a delay here if needed for better UX
        await Task.Delay(50);

        // Set the corresponding NoteLine to editing mode if it exists
        var lineToEdit = Lines.FirstOrDefault(l => l.Id == currentFocusedId);
        if (lineToEdit != null)
        {
            // Logic to trigger editing mode on this specific line can be added here if needed.
            // This may involve invoking a method on the NoteLine component if necessary.
        }
    }

    private async Task HandleLineUpdated((int Id, string Content) updatedLine)
    {
        await new Task(() => { });
        var (id, updatedContent) = updatedLine;

        NoteLineDto? line = Lines.FirstOrDefault(l => l.Id == id);
        if (line == null)
        {
            Snackbar.Add("Line not found.", Severity.Error);
            return;
        }

        line.Content = updatedContent;
        Logger.LogInformation("Note line updated!");
        @* await NotesService.UpdateNoteLineAsync(id, NoteId, updatedContent); *@
    }
}